SSH Accout Info: ctf / ctf1234_smiley

문제에 접속하면 스크린샷과 같은 ----로 둘러쌓인 캔버스가 생성되고 거기에 입력을 할 경우 입력한 것과 다른 문자열이 출력된다.
대충 입력되는 결과를 추론하면 입력한 문자 + 랜덤 5문자가 붙어서 출력된다.
그래서 해당 로직을 우회해서 무언가를 해야하나 싶었는데 그냥 컨트롤 C를 누르면 shell이 획득되었다.
혹시나 해서 ls 를 수행후 flag를 읽으니 문제가 풀렸다??

제공된 Dockerfile에는 flag를 옮기는 부분이 비어있어서 파일이 안보이는 것 같다.

알고보니 누가 server flag file의 permission을 바꿔놔서 발생했던 happening

다시 분석한 결과는 다음과 같음.

먼저 캔버스에 입력하려고 할 때 랜덤 문자 5개가 추가되는 것 까진 동일.
그러나 \x1b와 \x7f에 대한 조건문이 존재하였는데 각각의 기능은 다음과 같음

\x1b - ascii table에서 확인했을 때 ESC 키였다. 즉, vim에서 shift + : 를 누른 것 처럼 몇 가지 명령을 실행할 수 있었다.

\x7f - Backspace로 입력한 값을 지울 수 있었다. 물론 지울 때도 입력 문자 + 추가된 문자 5개가 같이 지워진다.

실행 가능한 명령

먼저 조건문으로 존재하는 명령은 save, load, clear, set, search, compile, quit 이었다.

이 중에서 종료를 뜻하는 quit는 당연히 프로그램이 종료되었고 set 명령어도 별도의 실행 없이 프로그램이 종료되었다.

save 명령은 현재 내용을 저장했다. 이때 저장되는 이름은 random한 hex 값이 생성되며 이를 ~/tmp/ 에 저장한다.

load 명령은 저장된 내용을 가져오며 load file명 형식으로 사용할 수 있었다. 그러나 경로가 ~/tmp로 고정되어 있기 때문에 사실상 save한 파일에 대해서만 가져올 수 있다.

clear 명령은 현재 입력한 내용을 전부 삭제해준다.

search 명령은 현재 파일 내에서 검색할 문자가 있는지 찾아준다. Line 별로 각 줄에 몇 개의 해당 문자가 있는지 찾아준다. 정규표현식 사용이 가능한 것으로 보인다.

compile 명령은 현재 입력된 내용을 바탕으로 gcc를 이용하여 compile을 진행한다. 이 기능이 핵심이라고 생각한 근거로 프로그램 상단에 setuid(0) 을 실행하기 때문에 root 권한으로 compile이 될 것이고, 이를 이용하면 flag를 읽을 수 있을 것이라 생각했다.

만약 filename을 control 할 수 있는 방법을 찾는다면 system(command) 형식으로 컴파일을 진행하기 때문에 이 부분에서 command injection도 가능하지 않을까 싶었다.
